self.HermesClass=function(t){"use strict";const{defineProperties:e,getOwnPropertyDescriptor:r,getPrototypeOf:n,setPrototypeOf:o,toString:s}=Object,{construct:c,ownKeys:p}=Reflect,u=new Set(["constructor","extends","static"]),i=(t,n)=>{const o={};for(const t of p(n))u.has(t)||(o[t]=r(n,t),o[t].enumerable=!1);e(t,o)},a={get:(t,e)=>(...r)=>{const s=t(),c=n(s),p=c[e];let u=c;for(;p===u[e];)u=n(u);try{return u[e].apply(o(s,u),r)}finally{o(s,c)}}},l={super:{get(){return new Proxy((()=>this),a)}}};return t.default=t=>{const{constructor:r,extends:n,static:p}=t,u=t.hasOwnProperty("constructor"),a=n?(t=>s.call(t).includes("[native code]"))(n)?function t(){const e=c(n,arguments,t);return u&&r.apply(e,arguments),e}:function(){const t=n.apply(this,arguments),e=t?o(t,y):this;return u&&r.apply(e,arguments),e}:u?function(){r.apply(this,arguments)}:function(){},{prototype:y}=a;return n&&(o(a,n),o(y,n.prototype),e(y,l)),p&&i(a,p),i(y,t),a},t}({}).default;
