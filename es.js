self.HermesClass=function(t){"use strict";const{defineProperties:e,getOwnPropertyDescriptor:r,getPrototypeOf:n,setPrototypeOf:o,toString:s}=Object,{construct:c,ownKeys:p}=Reflect,u=new Set(["constructor","extends","static","super"]),i=(t,n)=>{const o={};for(const t of p(n))u.has(t)||(o[t]=r(n,t),o[t].enumerable=!1);e(t,o)},a={get:(t,e)=>(...r)=>{const s=t(),c=n(s),p=c[e];let u=c;for(;p===u[e];)u=n(u);try{return u[e].apply(o(s,u),r)}finally{o(s,c)}}},f={super:{get(){return new Proxy((()=>this),a)}}};function l(t){return this[t]}return t.default=t=>{const{constructor:r,extends:n,static:p,super:u}=t,a=t.hasOwnProperty("constructor"),y=n?(t=>s.call(t).includes("[native code]"))(n)?function t(){const e=c(n,u?u.map(l,arguments):arguments,t);return a&&r.apply(e,arguments),e}:function(){const t=n.apply(this,u?u.map(l,arguments):arguments),e=t?o(t,h):this;return a&&r.apply(e,arguments),e}:a?function(){r.apply(this,arguments)}:function(){},{prototype:h}=y;return n&&(o(y,n),o(h,n.prototype),e(h,f)),p&&i(y,p),i(h,t),y},t}({}).default;
